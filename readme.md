# Проект для кубка РТК
Пожелания, жалобы, конструктивная критика и тому подобное принимается в [вк](https://vk.com/al_kom_ru).

![Фото9](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/9.png?raw=true)

## Задействованная переферия
Проект задействует следующую перефирию:
+ DMA1 и TIM3 для работы с адресными светодиодами;
+ TIM4 для реализации функций задержек;
+ PA10,PA11,PA12,PA15,PB3,PB4 для работы с LCD дисплеем;
+ SPI2 и PA9 для работы с динамиком;
+ PA1 для тактовой кнопки.

## Тактирование проекта
Проект настроен на рабочую частоту 72МГц при внешнем кварце на 12 Мгц. В случае если будет использоваться внешний кварц не равный 12МГц, то нужно изменить настройки тактирования:
1. В файле system_stm32f10x.c нужно изменить множитель для PLL. Находится необходимый множитель в строке №1056.

   ![Фото1](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/1.png?raw=true)
   
2. Также для надежности (так действительно надо) в настройках самого проекта прописана частота внешнего источника. Если это значение не поменять, то часть перефирии будет думать, что частота одна, а другая часть, что другая.

   ![Фото2](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/2.png?raw=true)

## Работа с проектом
Основное управление осуществляется файлом ***Prj_config.h***, в котором можно включать и отключать модули. На данном этапе для включения всех модулей одновременно не хватает памяти микропроцессора. Более тонкая настройка модулей осуществляется в их библиотеках с помощью директив. Например, как на рисунке ниже. 

   ![Фото7](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/7.png?raw=true)

## Работа отдельных модулей
### 1. Светодиодная матрица

Для инициализации матрицы необходимо вызвать функцию	***ws2812b_init()***. После этого, заполняя буфер данных необходимыми значениями (ф-ция ***int ws2812b_set(int pixn, uint8_t r, uint8_t g, uint8_t b)*** ), при помощи фун-ции ***int ws2812b_send(void)*** DMA1 осуществляет отправку всего массива в матрицу. 

Для работы с режимами необходимо вызвать фун-цию ***void Turn_on_Led_mode(uint8_t mode)***, которая запустит заранее реализованный режим (на данный момент их 3). Функция принимает номер режима.

Для более удобной работы со светодиодами реализована функция перевода цветов из модели HSV в модель RGB (***void HSV(int H, int S, int V)***). Данная функция после ее выполнения записывает в глобальную структуру ***rgb_struct*** три полученных цвета. Далее, из этой структуры можно эти цвета записать в массив для отправки в ленту.

### 2. Дисплей

Инициализация дисплея осуществляется функцией ***void LCD_Init(void);***. В самом низу тела этой функции есть отправка команд с настройками. На данном этапе нет реализации гибкой подстройки дисплея во время работы, вся настройка осущствляется этими четырьмя командами.

Далее монжо обзаться с дисплеем при помощи следующих функций:
+ ***void PrintStr(char *Text);***
Отправка строки на экран.
+ ***void PrintVar(int x);***
Отправка переменной на экран.
+ ***void ClearLCDScreen(void);***
Очистка всего экрана.
+ ***void Cleaning (int row, int col, int number);***
Очистка кусочка дисплея.
+ ***void Cursor(char Row, char Col);*** 
Установка курсора в необходимое место
+ ***void SendByte(char ByteToSend, int IsData);***
Отправка байта данных. Может быть как обычными данными, так и командой для дисплея (в зависимости от аргумента IsData).

### 3. Динамик

#### Работа с библиотекой

Иниицализация осуществляется функцией ***Speex_Init()***. Она осуществит настройки самой библиотеки libspeex, а также настроит SPI2 и таймера. 

Вторая функция - это запуск аудио на динамике ***void play_message(unsigned char const *array, uint16_t frame_number)***, она принимает указатель на массив с аудио и кол-во фреймов в этом массиве (размер массива / 20). После ее запуска с частотой 8кГц будет срабатывать прерывание от таймера и отправляться данные по SPI2 в ЦАП, который выдаст уровень на динамик. Функция использует два массива: пока один отправляется в ЦАП, во второй декодируются новые данные, а потом наоборот.  

#### Подготовка массива для воспроизведения на динамике
Допустим в начале мы имеем какую то аудяшку, а в итоге нам необходимо получить массив в файле voice.h. Как сделать?

Вот тяк:
1. Для начала переведем его в нужный формат. Я для этого использую программку [jetAudio](http://www.jetaudio.com/download/). 
   + Открываем прогу, отображаем содержимое компа (1), 
   + находим нашу аудио и нажимаем пару раз (2), 
   + далее внизу нажимаем кнопку конверта (3).

  ![Фото3](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/3.png?raw=true)

2. + Далее добавляем нашу аудио в список (1), 
   + задаем имя (2), 
   + выбираем необходимый формат (3), 
   + настраиваем формат (4 и 5) (настройки должны быть слудующие: 8kbit/s 8kHz Mono Q4), 
   + и нажимаем кнопку старт(6).

  ![Фото4](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/4.png?raw=true)
  
3. Далее необходимо отрубить заголовок нашему файлу. Важно не промахнутсья. В интернете пишут, что заголовок занимает 192 байта, то есть 12 строк. Однако, мной выяснено, что это не всегда так. В моих файлах заголовок занимает 160 байт. Итак, открываем файл в hex-редакторе, я использую HexEditorNeo. В тех файлах, что редактировал я, начиная со 152го байта идет слово "data", далее 4 байта, характеризующие размер данных и СРАЗУ после этого начинаются данные. Соответсвенно, удаляем первые 160 байт (10 строк) и сохраняем файл.
  
  ![Фото5](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/5.png?raw=true)
  
4. Далее изменяем формат нашего файла с audio.wav на audio.raw. Сделать это можно обычным переименовыванием, например
5. После нужно превратить наш файл в voice.h. Для этого в корне проекта есть файл bin2h.exe. Открываем консоль и прописываем следующую команду:

 ***путь/до/программы/bin2h.exe путь/до/файла/audio.raw путь/куда/сохранить/voice.h***

 ![Фото6](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/6.png?raw=true)
 
После этого на рабочем столе появляется файл voice.h, который уже можно или подключать или забирать из него массив в проект. ВАЖНО: размер массива должен быть кратен 20, если это не так, то где-то при подготовке файла была допущена ошибка. Если он не кратен, то от ожидаемого звука не останется и следа. 

Итог проделанных преобразований должен выглядеть так:

![Фото8](https://github.com/KomarovAlexandr/Photo_repository/blob/master/CupRTC/8.png?raw=true)
  
  
